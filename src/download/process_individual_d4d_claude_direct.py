#!/usr/bin/env python3
"""
Direct Claude Code synthesis of individual D4D YAMLs.

This script documents the process of generating individual D4D YAMLs using Claude Code
assistant direct synthesis, following the same deterministic principles as concatenated files.

Since these were generated by Claude Code assistant reading files directly,
this script serves as documentation and metadata generator for those manually created files.

For API-based automated generation, use process_individual_d4d_claude_api.py instead.

Author: Claude Code Assistant
Version: 1.0.0
Date: 2025-11-15
"""

import argparse
import hashlib
import json
import os
import subprocess
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional

import yaml


def calculate_file_hash(file_path: Path) -> str:
    """Calculate SHA-256 hash of a file."""
    sha256 = hashlib.sha256()
    with open(file_path, 'rb') as f:
        for chunk in iter(lambda: f.read(4096), b''):
            sha256.update(chunk)
    return sha256.hexdigest()


def get_git_commit() -> Optional[str]:
    """Get current git commit hash."""
    try:
        result = subprocess.run(
            ['git', 'rev-parse', 'HEAD'],
            capture_output=True,
            text=True,
            check=True,
            timeout=5
        )
        return result.stdout.strip()
    except (subprocess.CalledProcessError, subprocess.TimeoutExpired, FileNotFoundError):
        return None


def generate_metadata_for_individual_d4d(
    input_file: Path,
    output_file: Path,
    project: str,
    schema_path: Path,
    system_prompt_path: Path,
    processing_time: float = 0.0
) -> dict:
    """
    Generate metadata for an individual D4D file created via Claude Code direct synthesis.

    Args:
        input_file: Path to input preprocessed file
        output_file: Path to output D4D YAML file
        project: Project name (AI_READI, CHORUS, CM4AI, VOICE)
        schema_path: Path to schema file
        system_prompt_path: Path to system prompt file
        processing_time: Processing time in seconds

    Returns:
        Metadata dictionary
    """
    timestamp = datetime.now(timezone.utc).isoformat()
    git_commit = get_git_commit()

    input_hash = calculate_file_hash(input_file)
    schema_hash = calculate_file_hash(schema_path)
    system_prompt_hash = calculate_file_hash(system_prompt_path)

    project_root = Path(__file__).parent.parent.parent

    metadata = {
        "extraction_metadata": {
            "timestamp": timestamp,
            "extraction_id": f"claudecode_individual_{input_file.stem[:8]}",
            "extraction_type": "individual_claude_code_direct",
            "processing_time_seconds": processing_time,
            "notes": "Direct synthesis by Claude Code assistant (not via API)"
        },
        "input_document": {
            "filename": input_file.name,
            "relative_path": str(input_file.absolute().relative_to(project_root.absolute())),
            "format": input_file.suffix.lstrip('.') or "txt",
            "size_bytes": input_file.stat().st_size,
            "sha256_hash": input_hash,
            "project": project
        },
        "output_document": {
            "filename": output_file.name,
            "relative_path": str(output_file.absolute().relative_to(project_root.absolute())),
            "format": "yaml"
        },
        "datasheets_schema": {
            "version": "1.0.0",
            "source": "local",
            "path": str(schema_path.relative_to(Path.cwd())),
            "sha256_hash": schema_hash,
            "loaded_at": timestamp
        },
        "d4d_agent": {
            "version": "1.0.0",
            "implementation": "claude_code_direct",
            "wrapper": "Claude Code Assistant",
            "wrapper_version": "1.0.0"
        },
        "llm_model": {
            "provider": "anthropic",
            "model_name": "Claude Sonnet 4.5",
            "model_version": "claude-sonnet-4-5-20250929",
            "temperature": 0.0,
            "max_tokens": 16000,
            "notes": "Direct synthesis by Claude Code assistant (simulating deterministic extraction)"
        },
        "prompts": {
            "system_prompt_file": str(system_prompt_path.relative_to(Path.cwd())),
            "system_prompt_hash": system_prompt_hash,
            "notes": "Individual file D4D extraction follows same principles as concatenated files"
        },
        "processing_environment": {
            "platform": os.uname().sysname,
            "python_version": f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}",
            "processor_architecture": os.uname().machine
        },
        "reproducibility": {
            "command": f"Claude Code direct synthesis from individual file",
            "environment_variables": {
                "ANTHROPIC_API_KEY": "not_required_for_direct_synthesis"
            },
            "random_seed": None,
            "deterministic_settings": True
        },
        "provenance": {
            "extraction_performed_by": "Claude Code Assistant",
            "extraction_requested_at": timestamp,
            "git_commit": git_commit,
            "notes": f"Deterministic D4D extraction from individual preprocessed file for {project} using Claude Code assistant directly (not API-based)."
        }
    }

    return metadata


def main():
    """
    Main entry point for documenting individual D4D file generation.

    This script is used to generate metadata files for D4D YAMLs that were
    created via Claude Code assistant direct synthesis.
    """
    parser = argparse.ArgumentParser(
        description="Generate metadata for individual D4D files created via Claude Code direct synthesis"
    )
    parser.add_argument(
        "-i", "--input",
        type=Path,
        required=True,
        help="Input preprocessed file path"
    )
    parser.add_argument(
        "-o", "--output",
        type=Path,
        required=True,
        help="Output D4D YAML file path (must already exist)"
    )
    parser.add_argument(
        "-p", "--project",
        type=str,
        required=True,
        help="Project name (AI_READI, CHORUS, CM4AI, VOICE)"
    )

    args = parser.parse_args()

    project_root = Path(__file__).parent.parent.parent
    schema_path = project_root / "src" / "data_sheets_schema" / "schema" / "data_sheets_schema_all.yaml"
    system_prompt_path = project_root / "src" / "download" / "prompts" / "d4d_concatenated_system_prompt.txt"

    if not args.output.exists():
        print(f"Error: Output file does not exist: {args.output}")
        print("D4D YAML must be created first (via Claude Code assistant)")
        sys.exit(1)

    # Generate metadata
    metadata = generate_metadata_for_individual_d4d(
        input_file=args.input,
        output_file=args.output,
        project=args.project,
        schema_path=schema_path,
        system_prompt_path=system_prompt_path
    )

    # Save metadata
    metadata_file = args.output.parent / f"{args.output.stem}_metadata.yaml"
    with open(metadata_file, 'w', encoding='utf-8') as f:
        yaml.dump(metadata, f, default_flow_style=False, sort_keys=False, allow_unicode=True)

    print(f"âœ… Metadata generated: {metadata_file}")


if __name__ == "__main__":
    main()
